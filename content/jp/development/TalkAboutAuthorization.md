---
title: あなたは誰？身元認証方法について簡単に話す
date: 2023-04-30 23:23:00
categories: Development
author: kai98k
tags:
  - Internet
  - Authorization
---

身元確認とセキュリティの問題は、現在でも依然として非常にホットな問題です。Http 自体は [ステートレス (Stateless)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview) であるため、各 Request/Response は独立しています。そのため、状態/情報管理 (stateful) を行うには session、cookie、token が必要になります。また、Redis の使用など、さまざまなアプリケーションが存在する可能性があります。

## Basic 認証

Basic 認証の仕組みは、クライアント（ブラウザやアプリケーションなど）がサーバーにリクエストを送信する際に、HTTP ヘッダーに Authorization フィールドを含めることです。このフィールドには、ユーザー名とパスワードの Base64 エンコーディングが含まれています。サーバーはリクエストを受信すると、Authorization フィールド内のユーザー名とパスワードをデコードし、それらが有効かどうかを検証します。ユーザー名とパスワードが有効な場合、サーバーは要求されたデータを返しますが、そうでない場合はエラーレスポンスを返します。

```
GET /secure-data HTTP/1.1
Host: example.com
Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=
```

この例では、ユーザー名は "username"、パスワードは "password" であり、Base64 エンコードされて Authorization フィールドの値になっています。サーバーはこの値をデコードし、平文のユーザー名とパスワードを使用して検証します。

Basic 認証は非常にシンプルで実装が容易ですが、いくつかの制限があります。最も明らかな制限は、ユーザー名とパスワードを平文で送信するため、攻撃者による盗聴やスニッフィングに対して脆弱であることです。また、Basic 認証には認証後に承認を継続するメカニズムがないため、より高いセキュリティ要件が必要なアプリケーションや API には適していません。そのため、現在では一般的に Basic 認証の使用は推奨されておらず、より安全な認証方法の使用が推奨されています。

## Session-based 認証

> 朝食店で注文するとき、客が店主に口頭で注文し、店主が食事と客の情報をコンピュータに入力して番号札を印刷し、客に渡すようなものです。客が食事を受け取るときは、番号札を再び店主に渡す必要があります。客は番号札を保管する責任があり、店主は各客のデータを管理し、番号札に従って対応するものを客に渡す責任があります。

ユーザーがクライアント（フロントエンド）でログインすると、アカウントとパスワードをサーバーに Post します。このとき、サーバー側のバックエンドプログラムはユーザー情報を使用して Session を作成し、クライアントに Session ID を返します。その後の Request では、この Session ID が Http Cookie に付加されます。サーバーが Request を受信したときに Session ID があることを発見すると、対応する Session ID を検索して、その Session に保存されているユーザーデータを取得できます。

### HTTP Cookie

HTTP cookie（web cookie、browser cookie）は、サーバーからユーザーのブラウザに送信される小さなデータ片です。ブラウザはそれを保存し、次のリクエストで同じサーバーに cookie を送り返すことがあります。これは、[ステートレス（stateless）HTTP プロトコルのステートフル情報](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview)を記憶します。

Cookies は主に 3 つの目的で使用されます：

1. セッション管理
   アカウントログイン、ショッピングカート、ゲームのスコア、またはサーバーが記憶すべきその他の情報

2. パーソナライズ
   ユーザー設定、テーマ、およびその他の設定

3. トラッキング
   ユーザー行動の記録と分析

上記の 3 つのポイントには機密データを含めるべきではありません。なぜなら、ユーザーは Cookie の値を任意に改ざんしてサーバーを騙すことができるからです。配置できるのは、そのデータに対応する ID です。

### Set-Cookie

Set-Cookie は HTTP ヘッダーであり、クライアント（ブラウザなど）とサーバーの間でユーザーセッションやその他の状態情報を含む小さなデータブロックを渡すために使用されます。通常はサーバー側でユーザーのブラウザの Cookie にデータを保存するため、サーバーは Cookie を介してユーザーを識別し、セッション状態を維持できます。

| Set-Cookie        | 属性の設定                                                  |
| ----------------- | ----------------------------------------------------------- |
| NAME=VALUE        | Cookie に付与する名前と値                                   |
| expires=DATE      | Cookie の有効期限、デフォルトはブラウザを閉じるまで         |
| path=PATH         | Cookie オブジェクトとしてのサーバー上のファイルディレクトリ |
| domain=ドメイン名 | Cookie オブジェクトのドメイン名                             |
| Secure            | HTTPS の場合のみ送信                                        |
| HttpOnly          | Javascript から Cookie にアクセスできないようにする         |

### Session 身元認証の欠点

1. セッションハイジャック：攻撃者が有効な Session ID を取得できた場合、ユーザーになりすましてユーザーデータにアクセスし、変更することができます。攻撃者は、公共の Wi-Fi で偽の Web サイトを使用して Session ID を盗むなど、いくつかの手法を使用する可能性があります。

2. CSRF 攻撃：クロスサイトリクエストフォージェリ（CSRF）攻撃は、被害者のブラウザでの認証権限を利用して、被害者の予期しない操作を背後で行う攻撃です。攻撃者は、脆弱な Web サイトへの偽造されたリクエストをブラウザに送信し、ユーザーの ID を利用して背後で他の保護された Web サイトにアクセスする可能性があります。

3. サーバー側からユーザーのセッションを簡単に中断できない：Session ID は通常、クライアントの Cookie に保存されるため、サーバーはユーザーのセッションを直接終了する方法がありません。サーバー側がセッションハイジャックや CSRF 攻撃を検出した場合でも、直接セッションを中断することはできず、セッションの有効期限が切れるか、ユーザーの Session ID をリセットするのを待つ必要があります。

これらのリスクを軽減するには、HttpOnly フラグと Secure フラグの使用、セッション期間の制限、Session ID の定期的なリセットなど、追加の対策を講じる必要があります。

### Cookie 同一生成元ポリシー (Same-Origin Policy)

Cookie 同一生成元ポリシーは、ブラウザ内の Web サイト間で Cookie を共有することを制限するために使用されるブラウザのセキュリティメカニズムです。同一生成元ポリシーに基づき、Web サイトは自分と同じプロトコル、ホスト、ポート番号を持つ Cookie にのみアクセスできます。これにより、ある Web サイトが他の Web サイトの Cookie にアクセスしたり変更したりするのを防ぎ、ユーザーのプライバシーとセキュリティを保護します。

たとえば、Web サイト A が Web サイト B の Cookie にアクセスしようとすると、ドメイン名が異なるため、ブラウザはそのリクエストを拒否します。同様に、Web サイト A が Web サイト B の Cookie に Cookie を書き込もうとした場合も、ドメイン名が異なるため拒否されます。

## Token-Based 認証

> 朝食店で注文するとき、一連の専門用語（大温微乳肉卵トーストポテト胡椒ありトマトなし）で店主に注文することを想像してください。このとき、店主は超強力な脳を使ってこの言葉の羅列がどのような食事を必要としているかを解析し、食事を受け取るときにもう一度言うだけで、店主はあなたが注文したものをくれます。

最初に Token の概念に触れたとき、なぜ「トークン（令牌）」と呼ばれるのか理解できませんでした。Basic 認証との原理の違いを理解するまでは。単に平文を Base64 にしてサーバーに送信するのではなく、機密情報を意味のない情報のセットに変換・暗号化し、この時点でこの意味のない情報のセットを Token と呼び、この動作を[トークン化 (Tokenization)](<https://en.wikipedia.org/wiki/Tokenization_(data_security)>) と呼ぶことを理解しました。

### 利点

1. サーバーに Session を保存する必要性を排除できる点にあります。従来の Session ベースの認証では、ユーザーがサーバーと対話する際に使用するために、サーバーはユーザーに関する Session をローカルに保存する必要があります。しかし、Token-based 認証では、必要なすべてのユーザー情報は Token に保存されます。

2. 複数のサーバーやサービスにまたがる認証が容易になります。ユーザーが異なるサーバーやサービス間で対話する場合、各サービスはセッションを共有したり、異なるサービス間で認証を行ったりすることなく、ユーザーの身元を確認できます。

### JWT

Token-based 認証を実装する場合、一般的な方法は JSON Web Token (JWT) を使用することです。JWT は、異なる当事者間で情報を安全に送信するための形式を定義するオープンスタンダードです。JWT には、ユーザーの身元情報、および有効期限や権限などのその他の関連情報を含めることができます。ユーザーが認証に合格すると、アプリケーションはクライアントに JWT を返し、クライアントはその後、サーバー側で認証を行うために、リクエストごとに JWT を携帯する必要があります。

JWT の構造は、次の 3 つの部分で構成されています：

1. Header：JWT のヘッダー部分には、トークンのタイプ、暗号化アルゴリズムなど、トークンに関するメタデータが含まれています。

2. Payload：JWT のペイロード部分には、ユーザー ID、ロール、権限など、アプリケーションのユーザー ID とその他のメタデータに関する情報が含まれています。

3. Signature：JWT の署名部分は、トークンが本物で有効であることを検証し、送信中に変更または置換されていないことを確認するために使用されます。

JWT の動作フローには通常、次の手順が含まれます：

1. ユーザーは、認証のために資格情報（ユーザー名やパスワードなど）をアプリケーションに送信します。
2. アプリケーションはユーザーの身元を確認し、ユーザー情報に基づいて JWT を作成します。
3. ユーザーは、その後のリクエストで JWT を送信します。
4. アプリケーションは JWT が正当かどうかを確認し、JWT 内の情報を使用してユーザーの身元と権限を確認します。
5. JWT の検証が成功すると、ユーザーは必要なリソースへのアクセス権を付与されます。

JWT には、複数のプラットフォームで使用できる、状態を保存する必要がない、高い拡張性と自己記述性があるなど、多くの利点があります。さらに、JWT を OAuth と組み合わせて使用することで、安全な認証と認可を実現し、ユーザーのプライバシーとデータセキュリティをさらに保護できます。

### OAuth

OAuth（Open Authorization）は、ユーザーのパスワードを共有することなく、ユーザーまたはアプリケーションが別のユーザーのリソースにアクセスすることを許可するために使用されるオープンスタンダードの認可プロトコルです。OAuth プロトコルは通常、ユーザーが自分のリソースと情報を安全に共有できるように、Web アプリケーションとサービス間の安全な認可に使用されます。

OAuth プロトコルは、「アクセストークン」（access token）と呼ばれるメカニズムを使用して、ユーザーの身元と権限を表します。OAuth の認可フローでは、ユーザーがリソースにアクセスしようとすると、リソースへのアクセスをサードパーティアプリケーションに許可するように求められます。ユーザーは自分のアカウントにログインしてから、そのアプリケーションに権限を付与することで、アプリケーションはユーザーのパスワードを知ることなく、ユーザーのリソースを使用できます。

OAuth プロトコルには、主に次の役割が含まれます：

- ユーザー（resource owner）：アクセスを許可する必要があるリソースを所有しています。
- サードパーティアプリケーション（client）：ユーザーのリソースにアクセスする必要があるアプリケーション。
- 認可サーバー（authorization server）：ユーザーの身元を確認し、トークンを付与するサーバー。
- リソースサーバー（resource server）：実際にユーザーリソースを保存するサーバー。

OAuth プロトコルのワークフローは、おおよそ次のとおりです：

1. サードパーティアプリケーションは認可サーバーにリクエストを送信し、ユーザーのリソースへのアクセス許可を要求します。
2. 認可サーバーはユーザーの身元を確認し、ユーザーに許可を求めます。
3. ユーザーは、サードパーティアプリケーションにリソースへのアクセスを許可します。
4. 認可サーバーはサードパーティアプリケーションにアクセストークンを送信します。これは、そのアプリケーションがユーザーのリソースへのアクセスを許可されていることを表します。
5. サードパーティアプリケーションは、アクセストークンを使用してユーザーのリソースにアクセスします。

OAuth プロトコルを使用することで、ユーザーはパスワードを共有することなく、サードパーティアプリケーションにリソースへのアクセスを許可できます。これは、ユーザーの機密情報のセキュリティを保護するのに役立ちます。同時に、OAuth プロトコルは、ユーザーが自分のリソースにアクセスできるアプリケーションを制御するのにも役立ち、自分のデータに対するユーザーの制御権を強化します。

OAuth プロトコルには、OAuth 1.0、OAuth 1.0a、OAuth 2.0 などの複数のバージョンがあります。その中で、OAuth 2.0 は最も一般的に使用されているバージョンであり、そのシンプルさ、使いやすさ、高い柔軟性、強力な拡張性により、多くの Web アプリケーションとサービス間の認証と認可の標準プロトコルになっています。

## まとめ

Session 認証は通常、cookie と session に基づいています。ユーザーがログインすると、サーバーは session オブジェクトを作成し、その一意識別子（session ID）をユーザーの cookie に保存します。ユーザーが再度サイトにアクセスすると、ブラウザは自動的に cookie をサーバー側に送信し、サーバー側は session ID が有効かどうかを確認し、session 内の情報に基づいてユーザーがログインしているかどうかを判断します。

対照的に、JWT 認証は JSON Web Token（JWT）に基づいています。JWT は、ネットワーク内で情報を安全に送信することを可能にするオープンスタンダードです。JWT 認証では、ユーザーがログインに成功すると、サーバーは JSON オブジェクトを作成し、キーを使用してそれを暗号化して Token にします。その後、その Token をクライアントに送信し、クライアントはそれを cookie に保存するか、他の方法で保存できます。ユーザーが再度サイトにアクセスすると、クライアントはその Token をサーバー側に送信し、サーバー側はキーを使用してそれを検証し、ユーザーの身元と権限を特定します。

全体として、Session 認証は通常、サーバー側で session オブジェクトを維持する必要があり、サーバーのリソースを消費し、クロスドメイン認証を十分にサポートできません。一方、JWT 認証はクライアント側で維持でき、クロスドメイン認証をサポートでき、優れた拡張性とセキュリティを備えています。

## Reference

https://squareball.co/blog/the-difference-between-basic-auth-and-oauth
