---
title: Interview
date: 2025-04-29
categories: Interview
author: johch3n611u
tags:
- Interview
---

演算法 資料結構 

系統架構 雲端 AWS Azure SideProject

題目 => 由 演算法 或 數據結構的特性 解出

AWS Certified Solutions Architect - Associate 

AWS Certified Developer Associate - Associate ✅

AZ-104 Azure Administrator Associate 

AZ-204 Azure Developer Associate ✅

# 怎刷

第一遍：知道。直接看答案，不要自己想，了解所有最优解，方法技巧第一。做题套路，以印象为主。

第二遍：熟悉。过easy题，记住；做medium，重点题背，反复背。最简单会，大多不会。记住做题套路，以记住为主。

第三遍：做题。做easy题；做部分medium题，hard题有思路。夯实medium基础。熟练运用做题套路，以做题为主。

面经：做面经，开阔思路，了解出题形式。基础决定上层建筑，基础牢轻松，不牢就痛苦

第四遍以上：刷题。

## 聚焦於實務面、常見於澳洲軟體工程師面試的關鍵演算法策略清單

- 雙指針 (Two Pointers)：處理排序陣列或滑動視窗問題，常用於配對、反轉陣列等情境 
- 滑動視窗 (Sliding Window)：在陣列或字串上動態維護子區間，用於最佳子陣列和、長度限制問題等 
- 快慢指針 (Fast & Slow Pointers)：偵測迴圈、尋找中點、判斷回文鏈結串列等 
- 二分搜尋 (Binary Search)：在已排序結構中做對數時間搜尋，也可延伸至答案空間二分 
- 排序演算法 (Sorting Algorithms)：熟悉 Quick Sort、Merge Sort、Heap Sort 等基本作法與複雜度 
- 雜湊表／映射 (Hash Tables/Maps)：利用 O(1) 平均時間完成查找、去重、計數等 
- 遞迴與回溯 (Recursion & Backtracking)：生成組合、排列、子集，解決子問題重疊時的狀態回溯 
- 貪心演算法 (Greedy Algorithms)：如任務排程、區間選擇，做本地最優以達成全局最優解 
- 分治法 (Divide and Conquer)：透過分割子問題（如 Merge Sort、Quick Select）降低問題規模 
- 樹結構演算法 (Tree Algorithms)：前／中／後序、層級遍歷、最低公共祖先等基本操作 
- 圖形演算法 (Graph Algorithms)：廣度優先搜尋 (BFS)、深度優先搜尋 (DFS)、Dijkstra 單源最短路徑等 
- 動態規劃 (Dynamic Programming)：如背包問題、最長遞增子序列 (LIS)、區間 DP 等常見題型 
- 矩陣／格狀遍歷 (Matrix / Grid Patterns)：連通區域計數 (Number of Islands)、洪水填充等 
- 合併區間 (Merge Intervals)：排序後按起點合併重疊區間，用於時間表調度等 
- 循環排序 (Cyclic Sort)：用於驗證或修正包含 1…n 的陣列





























































# BigO 最糟狀況耗時

目的：簡化版演算法成本分析複雜度

計算特色：高次方 > 低次方 + 忽略底數 (算大概)

預設底數為 2（也就是 log₂ n = log n），因為大多數演算法的拆分都是「每次切一半」。

|BigO|複雜度|範例|
|----|----|----|
|n⁰=(1)|一步|index搜尋|
|log n|階層|二元搜尋|
|n|線性|陣列遍歷|
|n log n|線性+階層|Merge Sort|
|n²|線性+線性(超級分支)|for(){for(){}} <br> Bubble Sort|
|2ⁿ|定速細胞分裂(後勢時間成本高)|費氏數列|
|n!|高速細胞分裂|排列組合|

https://www.desmos.com/calculator






































# 資料結構

## Array 陣列, 易取, 難插, 難刪除, 記憶體要連續 [值, 值, 值]

實例：聯絡人列表、二維圖像

特點：快速的隨機存取（O(1)）、插入與刪除操作效率較低，尤其是在中間位置

複雜度：增 n  / 刪 n / 查 n⁰=(1)

## Linked List 連結串列, 難取, 好插, 好刪除, 記憶體可分散 [值, 位置] [值, 位置]

實例：播放清單動態增刪、GPS 導航系統動態更新路線

特點：插入與刪除操作效率高（O(1)），但隨機存取效率低（O(n)）。

複雜度：增 n + n⁰ / 刪 n + n⁰ / 查 n

## Stack 堆疊, 先進後出, 可以用 Array 與 Linked List 做出來, 

實例：Undo/Redo, 上一頁

特點：插入與刪除操作僅在頂端進行。

複雜度：增 1 / 刪 1 / 查 n

## Queue 佇列, 先進先出, 可以用 Array 與 Linked List 做出來, 

實例：排隊, 搶票, 任務管理排程

特點：插入操作在尾端，刪除操作在前端。

複雜度：增 1 / 刪 1 / 查 n

## Set 集合, 值不能重複, 可存物件或陣列但是存位址參考來判斷重複, 可透過 hash 判斷重複

實例：使用者權限應用、資料去重、數學集合運算交集聯集差集

特點：通常使用雜湊表（Hash Table）實作，以提供快速查找。

複雜度：增  / 刪  / 查 

## Map 映射, key value

實例：字典應用、快取

特點：快速的查找、插入與刪除操作。

複雜度：增 n / 刪 n / 查 n

## tree 樹, 不含迴路, 子節點可以很多但 2 節點只有唯一路徑, n 個節點 n-1 路徑, 只要增加任意一個路徑就會形成迴路, 遍歷方式 Pre-order / In-order / Post-order 幾種遍歷方式

實例：目錄結構、資料庫索引、網頁 DOM、組織結構

特點：層級結構，適合表示具有父子關係的資料。

複雜度：增  / 刪  / 查 

## Graph 圖, 樹的放大但節電必須整個都有路徑

實例：社交網路、地圖與導航、網路拓撲設備連接、使用者與產品推薦系統

特點：節點（Node）與邊（Edge）組成，可表示複雜的關聯關係。

複雜度：增  / 刪  / 查 

## Binary Tree 二元樹, 樹的縮小, 子節點只能兩個, 層數降低 => 完全二元樹 左右較隊稱, 滿二元樹 完全對稱

實例：數學表達式解析、搜尋演算法、堆積排序（Heap Sort）

特點：每個節點最多有兩個子節點。結構簡單，適合實作各種演算法。

複雜度：增 log n / 刪 log n / 查 log n

## Binary Search Tree 二元搜尋樹, 二元樹的縮小, 往左邊的一定比右邊小

實例：動態維護排序的資料、搜尋引擎的關鍵字建議、查找特定範圍內的資料

特點：左子樹的值小於根節點，右子樹的值大於根節點。提供平均 O(log n) 的查找效率。

複雜度：增 log n  / 刪 log n / 查 log n

## Red Black Tree 紅黑樹, 二元樹的縮小, 因為二元樹有機會長歪變成大象角, 紅黑樹則是自動平衡的二元搜尋樹

實例：用於儲存排序的鍵值對或集合、提供自動排序的容器、作業系統排程

特點：自平衡的二元搜尋樹。保證最壞情況下的操作時間為 O(log n)。

複雜度：增  / 刪  / 查 

## Heap 堆積, 特別的完全二元樹, 樹的根與父節點永遠小或大於子節點, 大堆積小堆積

實例：排程優先佇列、圖形演算法、系統資源分配、急診室檢傷

特點：特殊的樹狀資料結構、需要快速存取最大值或最小值的情境。

複雜度：增 log n  / 刪 log n  / 查 1

## Hash 雜湊演算法 將資料壓縮

實例：資料庫索引、快取、密碼儲存與數位簽章、字典與集合實作

特點：透過雜湊函數將鍵映射到值的資料結構，要注意雜湊衝突

複雜度：增 n / 刪 n / 查 n


















































# CRACKING THE CODING INTERVIEW 分類題目

Arrays 陣列 最容易出現的考題

Linked Lists 鏈結串列

Stacks and Queues 堆疊與序列

Trees and Graphs 樹與圖 第三多的考題

Hash table 雜湊表

Bit Manipulation 位元運算

Math and Logic Puzzles 數學與邏輯

Recursion and Dynamic Programming 遞迴與動態規劃 次多出現的考題

Sorting and Searching 排序與搜尋

matrix 矩陣










































# 演算法策略 = 解問題套路 != 不是具體演算法

## 1. 暴力穷举（Brute-Force） 全部試一遍
**定義**：枚舉所有可能解並逐一測試，直到找到符合條件者。  
**特點**：
- 簡單易實作
- 時間複雜度高（如 O(n!)、O(n^k)）
- 僅適合小規模問題  
**示例**：
- 破解密碼（嘗試所有組合）
- 子集和問題的暴力法
- 判斷阿姆斯特朗數
- 解百雞

---

## 2. 分而治之（Divide and Conquer） 拆成小問題遞迴處理
**定義**：將問題拆成若干相似子問題，遞迴求解並合併。  
**特點**：
- 常見於排序與搜尋
- 時間複雜度：T(n) = aT(n/b) + f(n)  
**示例**：
- Merge Sort（歸併排序）
- Quick Sort（快速排序）
- Strassen 矩陣乘法
- 遞迴
- 二分查找 Binary Search
- 歸併排序
- 快速排序
- 漢諾塔

---

## 3. 減而治之（Decrease and Conquer）
**定義**：
- 每次減少問題規模（如 n-1）
- 或將問題轉換為熟知問題再求解  
**特點**：
- 通常僅生成一個子問題
- 合併階段簡單  
**示例**：
- 二分搜尋（每次減半）
- 插入排序
- 中位數選擇（排序後取中間）
- 拓撲排序
- Dijkstra 算法
- kahn's algorithm 執行拓撲排序的一種經典算法，有向無環圖（DAG）

---

## 3. 轉化法 (Transform and Conquer)

**定義**：
- 將原問題轉換為等價但更容易處理的形式，再用簡單或熟悉的算法來解決。
**特點**：
- 核心在於「轉化」——不直接處理原始問題，而是先做改寫或重構。
- 通常只轉化一次或少數幾次，非逐步縮小。
- 可以搭配其他策略（如排序後再貪心）。
- 常見於結構轉換（資料結構）或數學建模轉換。
**示例**：
- Heap Sort：將無序陣列轉化為最大堆，再重複取出最大值排序。
- 自平衡搜尋樹（如 AVL / Red-Black Tree）：轉化資料結構來保持查詢、插入為 O(log n)。
- 多項式乘法使用 FFT（快速傅立葉轉換）：將乘法問題轉化為點值表示，再進行乘法與反轉換。
- 編譯器語法樹轉為後綴表示法：更容易進行計算或代碼生成。
- 排序 + 處理問題：例如「活動選擇問題」：先把活動按結束時間排序，轉化後再用貪心法。

---

## 4. 贪心法（Greedy） 每步都選當下最好的
**定義**：每步選擇當前看來最優（局部最優）解，希望導出全局最優解。  
**特點**：
- 簡單高效（如 O(n) 或 O(n log n)）
- 僅適用於滿足“贪心選擇性”與“最優子結構”的問題  
**示例**：
- 活動選擇問題
- Kruskal / Prim 演算法（最小生成樹）
- Huffman 編碼
- 最小生成樹
- 算法背包
- 問題單元最短路徑 Diikstra
- Huffman壓縮編碼
- Dijkstra’s Algorithm 迪傑斯特拉演算法 單源最短路徑問題 ✅
- kahn's algorithm

---

## 5. 動態規劃（Dynamic Programming） 記住以前算過的結果
**定義**：將問題分解為重疊子問題，保存子問題結果以避免重複計算。  
**特點**：
- 適用於“最優子結構”+“重複子問題”
- 時間複雜度依狀態數與轉移次數（如 O(n×m)）  
**示例**：
- Floyd、Bellman-Ford（最短路徑）
- 0/1 背包問題
- 編輯距離（Edit Distance）
- 爬樓梯
- 背包
- 硬幣找零
- 圖的全源最短路徑
- 最常公共子序列
- 斐液那契數列
- Dijkstra 算法

---

## 6. 回溯法（Backtracking） 試一條路，不通就回頭
**定義**：在解空間樹中探索可行解，若發現不合法則回退嘗試其他分支。  
**特點**：
- 類似 DFS，常用於約束滿足問題（CSP）
- 最壞情況仍為指數時間，效率依賴剪枝  
**示例**：
- N 皇后問題
- 數獨解題
- 圖著色、子集求和
- 深度優先搜尋 BFS
- DFS
- 0-1背包
- 正則表達式匹配
- 八皇后
- 數獨
- 全排列

---

## 7. 分支限界（Branch and Bound） 加上剪枝加速搜尋
**定義**：在回溯基礎上加入上下界估計進行剪枝，優化搜尋過程。  
**特點**：
- 常用於組合優化問題
- 需設計良好的界函數  
**示例**：
- 旅行商問題（TSP）
- 整數線性規劃

---

## 8. 隨機化演算法（Randomized）
**定義**：在某些步驟引入隨機選擇，以提高效率或簡化設計。  
**特點**：
- 包括蒙特卡洛與拉斯維加斯兩類
- 常用於大數據或近似計算  
**示例**：
- 隨機化快速排序
- 隨機選擇（Randomized Select）
- 網路流量近似估計

---

## 9. 啟發式／近似（Heuristic / Approximation） 用經驗猜、非最優也可接受
**定義**：依據經驗或問題特性設計非最優但實用的解法。  
**特點**：
- 多用於 NP 難題與實務應用
- 無法保證最差情況下的效能，但實際效果常佳  
**示例**：
- 最近鄰啟發式（解 TSP）
- 遺傳演算法（Genetic Algorithm）
- 模擬退火（Simulated Annealing）
- A*（A star）算法

## 工具技巧

1. 遞迴：不是策略，可實作分而治之、回溯、動態規劃等策略的工具之一
2. Breadth-First Search BFS：常被用來實作最短路徑、狀態轉移類 DP 問題
3. Depth-First Search DFS：常被用來實作回溯法、分支限界
